<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>21-map方法</title>
</head>

<body>
    <h1>21-map方法</h1>

    <script>
        /*   var t = [1, 3, 9, 90, 4, 20];
   
           for (var i in t) {
               console.log(t[i]);
           }
   
           // 对数组中的每个元素都进行*2，打印结果数组。
           // map方法，返回一个新数组，每个处理完成后的结果组成的新数组
           // 对原素数组没有影响
           var m = t.map(function (item, index, array) {
               // item : 就是当前的选项。
               // index:当前选项的索引。
               // array：当前数组
               // return  返回每个处理的结果
   
               return item * 2;
           });
           console.log(t);
           console.log(m);
   */
        var arr = [1, 5, 2, 7];
        // 快速排序 原理：
        // 1. 判断数组的长度 <= 1 返回数组
        // 2. 否则 
        // 3. 用Math.floor，求出数组的下舍入的索引pivotIndex，
        // 4. 用Array.prototype.splice，从下舍入的值的pivotIndex开始删，删除一个元素，得到返回的删除的元素
        // 5.定义left = [] ,right = []
        // 6.遍历arr数组
        // 7.对比如果小于等于pivot的，插入left数组，否则插入right
        // 8.这样子能够分成两个数组，以pivot为中间的
        // 9.递归 执行left数组 连接上pivot，递归执行right数组
        // 10.直到数组的长度 <=1 返回arr
        function quickSort(arr) {
            if (arr.length <= 1) { return arr; }

            //  Math.floor(x) 对x下舍入，  // 5.1  => 5  5 => 5  -1.2 => -2
            var pivotIndex = Math.floor(arr.length / 2);

            var pivot = arr.splice(pivotIndex, 1)[0];

            var left = [];
            var right = [];

            for (var i = 0; i < arr.length; i++) {
                if (arr[i] <= pivot) {
                    left.push(arr[i]);
                } else {
                    right.push(arr[i]);
                }
            }

            // 递归
            return quickSort(left).concat([pivot], quickSort(right));
        }

        console.log(quickSort(arr));
    </script>
</body>

</html>